import NetServiceFactory from './netServiceFactory'
import { writeInfo, writeError } from './logger';

const protoLoader = require('@grpc/proto-loader');

const grpc = require('grpc');

const PROTO_PATH = path.join(__dirname, '..', 'proto/api.proto');
const packageDefinition = protoLoader.loadSync(PROTO_PATH);
const spacemeshProto = grpc.loadPackageDefinition(packageDefinition);

const getDeadline = () => new Date().setSeconds(new Date().getSeconds() + 120000);

class PoSTService extends NetServiceFactory {
  constructor() {
    super('proto/smesher.proto', 'localhost:9091', 'SmesherService');
  }

  //
  //     // Stop smeshing and optionally attempt to delete post init file(s)
  //     // Returns success if request is accepted by node, error if it fails
  //     rpc StopSmeshing(StopSmeshingRequest) returns (StopSmeshingResponse);
  //
  //     // Get the current smesher id generated by the node
  //     rpc SmesherID(google.protobuf.Empty) returns (SmesherIDResponse);
  //
  //     // Get the current coinbase
  //     rpc Coinbase(google.protobuf.Empty) returns (CoinbaseResponse);
  //
  //     // Set the coinbase
  //     // Returns success if request succeeds, failure if it fails
  //     rpc SetCoinbase(SetCoinbaseRequest) returns (SetCoinbaseResponse);
  //
  //     // Get the current min gas for including txs in blocks by this smesher
  //     rpc MinGas(google.protobuf.Empty) returns (MinGasResponse);
  //
  //     // Set a min gas units for including txs in blocks by this smesher
  //     // Returns success if request succeeds, failure if it fails
  //     rpc SetMinGas(SetMinGasRequest) returns (SetMinGasResponse);
  //
  //     // Estimate smeshing rewards over the next upcoming epoch
  //     rpc EstimatedRewards(EstimatedRewardsRequest) returns (EstimatedRewardsResponse);
  //
  //     /////// Proofs of space data files management
  //
  //     // Returns post data status from the node
  //     rpc PostStatus(google.protobuf.Empty) returns (PostStatusResponse);
  //
  //     // Returns a list of available post compute providers for creating post data
  //     rpc PostComputeProviders(google.protobuf.Empty) returns (PostComputeProvidersResponse);
  //
  //     // Starts (or continues) a post init phase. Supports resuming a previously
  //     // started init session, as well as changing post params (e.g., post data size)
  //     // after initial setup.
  //     // Returns success if request is accepted by node, failure if it fails
  //     rpc CreatePostData(CreatePostDataRequest) returns (CreatePostDataResponse);
  //
  //     // Stop an ongoing post data init phase and optionally attempt to delete
  //     // the post data file(s)
  //     // Returns success if request is accepted by node, failure if it fails
  //     rpc StopPostDataCreationSession(StopPostDataCreationSessionRequest) returns (StopPostDataCreationSessionResponse);
  //
  //     // STREAMS
  //
  //     // Returns a stream of updates to post data file(s) during the init phase
  //     rpc PostDataCreationProgressStream(google.protobuf.Empty) returns (stream PostDataCreationProgressStreamResponse);

  isSmeshing = () =>
    new Promise((resolve, reject) => {
      this.service.IsSmeshing({}, { deadline: new Date().setSeconds(new Date().getSeconds() + 200) }, (error, response) => {
        if (error) {
          writeError('PoStService', 'grpc isSmeshing', error);
          reject(error);
        }
        writeInfo('PoStService', 'grpc isSmeshing', response.is_smeshing);
        resolve(response.is_smeshing);
      });
    });

  startSmeshing = () =>
    new Promise((resolve, reject) => {
      this.service.StartSmeshing({}, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc getNodeStatus', error);
          reject(error);
        }
        writeInfo('netService', 'grpc getNodeStatus', { response });
        resolve(response);
      });
    });

  getStateRoot = () =>
    new Promise((resolve, reject) => {
      this.service.GetStateRoot({}, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc getStateRoot', error);
          reject(error);
        }
        writeInfo('netService', 'grpc getStateRoot', { response });
        resolve(response);
      });
    });

  getMiningStatus = () =>
    new Promise((resolve, reject) => {
      this.service.GetMiningStats({}, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc getMiningStatus', error);
          reject(error);
        }
        writeInfo('netService', 'grpc getMiningStatus', { response });
        resolve(response);
      });
    });

  initMining = ({ logicalDrive, commitmentSize, coinbase }) =>
    new Promise((resolve, reject) => {
      this.service.StartMining({ logicalDrive, commitmentSize, coinbase }, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc initMining', error);
          reject(error);
        }
        writeInfo('netService', 'grpc initMining', { response }, { logicalDrive, commitmentSize, coinbase });
        resolve(response);
      });
    });

  getUpcomingAwards = () =>
    new Promise((resolve, reject) => {
      this.service.GetUpcomingAwards({}, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc getUpcomingAwards', error);
          reject(error);
        }
        writeInfo('netService', 'grpc getUpcomingAwards', { response });
        resolve(response);
      });
    });

  getAccountRewards = ({ address }) =>
    new Promise((resolve, reject) => {
      this.service.GetAccountRewards({ address }, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc getAccountRewards', error);
          reject(error);
        }
        writeInfo('netService', 'grpc getAccountRewards', { response }, { address });
        resolve(response);
      });
    });

  setRewardsAddress = ({ address }) =>
    new Promise((resolve, reject) => {
      this.service.SetAwardsAddress({ address }, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc setRewardsAddress', error);
          reject(error);
        }
        writeInfo('netService', 'grpc setRewardsAddress', { response }, { address });
        resolve(response);
      });
    });

  getNonce = ({ address }) =>
    new Promise((resolve, reject) => {
      this.service.GetNonce({ address }, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc getNonce', error);
          reject(error);
        }
        writeInfo('netService', 'grpc getNonce', { response }, { address });
        resolve(response);
      });
    });

  getBalance = ({ address }) =>
    new Promise((resolve, reject) => {
      this.service.GetBalance({ address }, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc getBalance', error);
          reject(error);
        }
        writeInfo('netService', 'grpc getBalance', { response }, { address });
        resolve(response);
      });
    });

  submitTransaction = ({ tx }) =>
    new Promise((resolve, reject) => {
      this.service.SubmitTransaction({ tx }, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc submitTransaction', error);
          reject(error);
        }
        writeInfo('netService', 'grpc submitTransaction', { response }, { tx });
        resolve(response);
      });
    });

  getAccountTxs = ({ account, startLayer }) =>
    new Promise((resolve, reject) => {
      this.service.GetAccountTxs({ account: { address: account }, startLayer }, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc getAccountTxs', error);
          reject(error);
        }
        writeInfo('netService', 'grpc getAccountTxs', { response }, { account, startLayer });
        resolve(response);
      });
    });

  getTransaction = ({ id }) =>
    new Promise((resolve, reject) => {
      this.service.GetTransaction({ id }, { deadline: getDeadline() }, (error, response) => {
        if (error) {
          writeError('netService', 'grpc getTransaction', error);
          reject(error);
        }
        writeInfo('netService', 'grpc getTransaction', { response }, { id });
        resolve(response);
      });
    });

  setNodeIpAddress = ({ nodeIpAddress }) => {
    this.service = new spacemeshProto.pb.SpacemeshService(nodeIpAddress, grpc.credentials.createInsecure());
  };
}

export default PoSTService;
