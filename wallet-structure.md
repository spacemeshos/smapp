# Spacemesh app wallet structure

## MOVED TO SMIP: https://github.com/spacemeshos/SMIPS/issues/17

---

## Version 0.1 - Currently implemented in Smapp.

## Wallet File Name
Wallet file name pattern is: `my_wallet__<creation_timestamp>.json`.
- Creation timestamp - An ISO date string with `:` chars replaced with `-`.

Example file name: `my_wallet_2020-05-26T09-53-06.105Z.json`.

---

## Wallet File Contents - Json Syntax
```
{
  "meta": {
    "displayName": <string>,
    "created": <string>,
    "netId": <integer>,
    "meta": {
        "salt": "Spacemesh blockmesh"
    }
  },
  "crypto": {
    "cipher": "AES-128-CTR",
    "cipherText": <string>
  },
  "contacts": [
    {
        "nickname": "Joe Doe",
        "address": "0afef01..."
    },
    ...
  ]
}
```

- `displayName` - Wallet's display name, up to 50 chars.
- `created` - Creation timestamp - same format as the timestamp in the wallet's file name.
- `netId` - Network id that this wallet is designated to work with. Currently unused. It will be used later to match a wallet file to a specific Spacemesh network. Legal values are 0-255.
- `cipher` - The name of the encryption algorithm used to encrypt and to decrypt the secret part of the wallet (cipher text). Currently only `AES-128-CTR` is supported.
- `cipherText` - Encrypted wallet's data. Hex string.
- `contacts` - array of contact objects. Contact object syntax:
    - `nickname` - Contact friendly name. String up to 50 characters.
    - `address` - 40 hex chars representing contact's 20 bytes address.

---

 A decrypted `cipherText` data has the following json syntax:

```
{
    mnemonic: <string>,
    accounts: [
        {
            displayName: <string>,
            created: <string>,
            path: <string>,
            publicKey: <string>,
            secretKey: <string>
        },
        ...
    ]
}
```

- `mnemonic` - 12 words concatenated in single string with single space between each word.
- `accounts` - array of account objects. Each object consists of:
    - `displayName` - account name up to 50 chars.
    - `created` - creation timestamp in the same format as in file name and the wallet's `created` timestamp field.
    - `path` - string in the form `0/0/<account number>`, where `account number` is integer representing serial number of accounts created in this wallet.
    - `publicKey` - hex string of the account's public key byte array.
    - `secretKey` - hex string of the account's secret key byte array.

---

## Minimal Wallet Json Example
```
{
    "meta":  {
        "displayName":"Main Wallet",
        "created": "2020-05-24T12-56-44.897Z",
        "netId": 0,
        "meta":{
            "salt": "Spacemesh blockmesh"
        }
    },
    "crypto": {
        "cipher":"AES-128-CTR",
        "cipherText": "0fbd900ce9cc02682..."
    },
    "contacts":[]
}
```

## TODO: add example of decrypted cipher text with 2 accounts here...

---

## Mnemonic and accounts key-pair generation
- The nemonic is created using the [bip39] spec.
- The library used in Smapp is [bip39](https://github.com/bitcoinjs/bip39).
- The mnemonic is generated by calling `bip39.generateMnemonic`. Result is 12 words string separated by white spaces.
- Use `bip39.validateMnemonic` to validate a mnemonic.


## Account Generation

- Call `bip39.mnemonicToSeedSync` with a mnemonic to generate a seed.

- The signature scheme used to generate signing keys and to derive new pairs from the seed is [ed25519](https://github.com/spacemeshos/ed25519). Note that this is a custom ed25519 signature scheme developed by Spacemesh and not the standard ed25519 signature scheme.

- To create user accounts in the wallet, use `ed25519.NewDerivedKeyFromSeed` to create a new key pair, with the following params:
    1. `seed` - From calling `bip39.mnemonicToSeedSync`.
    2. `index` - Account's serial number. e.g 0, 1, 2...
    3. `salt` - String "Spacemesh blockmesh" encoding using UTF-8 to a byte array.

The first wallet's account should be the derived account index 0, the second at 1, etc... Do not use the a master key-pair generated from the seed directly for user accounts. User accounts should always be used using ed25519.NewDerivedKeyFromSeed.

### Spacemesh BIP32 paths
`m / 44' / coin_type` / [account] / 0 / [address_index]`

- Account should be constant 0 for now. May be used in the future for additional functionality.
- Coin type is `1` for a Spacemesh Testnet and `540` for Spacemesh mainent.
- The first mainent account should be at path `m / 44` / 540` / 0 / 0 / 0`.
- The second mainent account should be at path  `m / 44` / 540` / 0 / 0 / 1`.
- The first testnet account should be at path `m / 44` / 1` / 0 / 0 / 0.
- The second testnet account should be at path  `m / 44` / 1` / 0 / 0 / 1.
- We have registered to have 540 for Spacemesh. see: https://github.com/satoshilabs/slips/pull/943
- `address_index` is int32 so there can be up to 2^32 addresses per wallet.


---

## Signing and encoding a simple coin transfer transaction
- Library used for signing a new transaction is [ed25519](https://github.com/spacemeshos/ed25519). Note that this is a custom ed25519 developed by Spacemesh and not the standard ed25519 library.
- Library used for encoding a transaction is [js-xdr](https://github.com/stellar/js-xdr).
1. Create xdr types by calling:

```
xdr.config((xdr1) => {
 xdr1.struct('InnerSerializableSignedTransaction', [
   ['AccountNonce', xdr1.uhyper()],
   ['Recipient', xdr1.opaque(20)],
   ['GasLimit', xdr1.uhyper()],
   ['Price', xdr1.uhyper()],
   ['Amount', xdr1.uhyper()]
 ]);
 xdr1.struct('SerializableSignedTransaction', [
   ['InnerSerializableSignedTransaction', xdr1.lookup('InnerSerializableSignedTransaction')],
   ['Signature', xdr1.opaque(64)]
 ]);
});
```

2. Create a `message` for the transaction data by calling:

```
new types.InnerSerializableSignedTransaction({
  AccountNonce: xdr.UnsignedHyper.fromString(<accountNonce>),
  Recipient: fromHexString(<receiver>),
  GasLimit: xdr.UnsignedHyper.fromString(<limit>),
  Price: xdr.UnsignedHyper.fromString(<price>),
  Amount: xdr.UnsignedHyper.fromString(<amount>)
});
```

with following parameters:

    1. `accountNonce` - The current integer account counter obtained from a full node.
    2. `receiver` - 40 hex chars string (last 20 bytes of bytes array of receiver's public key).
    3. `limit` - Provided transaction gas limit fee in smidge units. string, currently fixed `5`.
    4. `price` - Transaction fee in smidge units provided by user. Should change to indicate gas price and work together with the limit field. e.g. `3`.
    5. `amount` - Amount to be send in the transaction in integer smidge units formatted as string. e.g. `20`.



3. Create a transaction with `message`:

    1. Translate the `message` to a byte array by calling `message.toXDR()`.
    2. Generate `signature` by signing the byte array by calling `ed25519.Sign2` with `secretKey` and the message's by array as parameters.
    3. Create a transaction using the `signature` and `message`:

```
new types.SerializableSignedTransaction({
  InnerSerializableSignedTransaction: message,
  Signature: signature
})
```

4. Sending a Transaction to a Full Node

    1. Serialize transaction as xdr by calling `transaction.toXDR()`.
    2. Send the serialized transaction to node using the node's API service.


---

## Wallet Creation Flows

### Obtain Encryption / Decryption Key from User's Password
1. User provides a password - at least 8 unicode characters.
2. We use [pbkdf2](https://github.com/crypto-browserify/pbkdf2) to derive an encryption key using the following method:

```
pbkdf2.pbkdf2Sync(password, "Spacemesh blockmesh", 1000000, 32, "sha512")
```
This key is used to encrypt and decrypt the wallet's file cipher-text binary data.

### Encrypt and Decrypt Wallet data
Only AES is currently supported and we use [aes-js](https://github.com/ricmoo/aes-js) in the following way:

### Encryption
1. Call `aes.utils.utf8.toBytes` on stringified json data to be encrypted to get the byte array representation of the data.
1. Call 'aes.ModeOfOperation.ctr(key, new aes.Counter(5))` where `key` is the encryption key we have created.
1. Call `aes.encrypt()` with byte array from step 1.
1. Call `aes.utils.hex.fromBytes` on the encrypted data result to get hex string representation to be saved in the wallet's file.

### Decryption
1. Call aes.ModeOfOperation.ctr(key, new aes.Counter(5))` where `key` is the encryption key we created before.
1. Call `aes.utils.hex.toBytes` on the encrypted hex string to get bytes array representation of the encrypted data.
1. Call `aes.decrypt` to decrypt the bytes array.
1. Call `aes.utils.utf8.fromBytes` to get a json stringified representation of decrypted wallet data.
1. Get the json data from the json string.
